Docker course
Comprehension DOcker
les etapes 
hello
COurs et comprehension 


La technologie de la virualisation :
1 Containers : APP1:Bin/LIB APP2:Bin/
Container Engine
Operatin System
Infrastructue

 Client Server :
 Docker client : Primary user when client push command and communicate with Docker Deamon:
        Docker build
        Docker Pull
        Dockker Run 


Docker Deamon: Where running Container

Docker_Host : Running DOcker client and Docker Deamon


Docker Deamon running in Linux VM in windows 10 (Docker machine )

Image (class)
    liy juste le template utilise pour creer de contenaire
    l image est creer avec ke docker build command ou par moi ou autre docker users
    l image comprend de couche (layers of images)
    il sont stok dans le Docker registry 

Container (instance de l image):
    runtime object
    on cree le Container from images. ds le container  il y a tout la dependence binaire pour rouler une application 

Registries and Repositories :
    la ou on stock  l image
    tu peux hoster ton propre regisstry ou tu peux utiliser celui de docker qui est publique qu on appelle DockerHub
    dans le registry, les images sont stocke dans le repositories.
    Docker REPOSITORY:
        Collection de different docker images avec le meme nom qui on diffents tags et chaque tag represent une version diffente d image 

Docker HUB: 
 Public Docker Registry 

  docker run busybox:1.24 echo "hello world"
   docker run busybox:1.24 ls

   the -i flag starts an interactivw container.
   the -t flag creates a pseudo -tty that attaches stin and stdout

        Naviguer dans l image:
             winpty docker run -i -t busybox:1.24


Foreground VS Detached :

The Linux Sleep COMMAND is used to delay for a specified amount of time
            docker run -d busybox:1.24  sleep 1000

            docker ps : verifier le container
            docker ps -a: pour verifier tous les containers
            docker run --rm busybox1.24 : fermer le container
           docker run --name hello_world busybox:1.24: pecify docker container we wna to run 

           Docker inspeck:
           $ docker run -d busybox:1.24 sleep 100


        docker inspeck $ docker run -d busybox:1.24 sleep 100
c22baf1cee09a0d5ab19f191238b7a72826348b4398c18a2c7bf79c2ffd90dad



TOMCAT CONTAINER(IMAGE):

 -p host-port: container_port

 winpty docker run -it -p 8888:8080 tomcat:8.0
  winpty docker run -it -d -p 8888:8080 tomcat:8.0: allow container running on the backround 


$ winpty docker run -it -d -p 8888:8080 tomcat:8.0
a8bbf4691458c9fd71f2b33fef29d7c3acc07cc0f39f32d8cd89c10c1ebd9f55


-===Voir le log :
    docker logs a8bbf4691458c9fd71f2b33fef29d7c3acc07cc0f39f32d8cd89c10c1ebd9f55




    DOCKER IMAGE LAYER :
        CONTAINERIMAGE


        to show layer image :  docker history busybox:1.24
        comme busybox est composer de deux couche 
        la couche de base pourr creer le file et la couche de commande Bash

        toutes les change se passe dans le writable layer
        quand le copntainer est delete le writable layer est delete aussi



    Build DOCKER IMAGE:
        commit changes made in a Docker Container 
        Write a DockerFile
            STEPS:
                sPIN UP a container from a base image
                Install Git Package in containerCommit Changes Made in the Container\
                On va utiliser DEBIAN (IMAGE LINUX)
                Run debian : 
                winpty docker run -it debian:jessie
                Install git in this container:
                    apt-get update && apt-get install -y git


                commit our container as a new docker image:
                    docker commit command would save the change we made in the container file system to a new image


                    docker commit container_ID repository_name:tag

                    executer la command docker ps -a pour avoir le ID du container

                        docker commit 9924c6cb3776 kimbo/debian:1.00
                        sha256:97cbbdb74fca1c4daa522d321b1c9f773fa829d01069c922346fc693cca6e9c2 : la nouvelle image qui porte mon nom (ID)

                    pour verifier l image creer :
                         docker images
                         la base la layer est le debian qui nous a permis de creer notre propre image 

                    pour rouler notre image :
                             winpty docker run -it kimbo/debian:1.00




    Build Docker Image with DockerFile:
        Document test avec les instruction que les users fournissent pour rassembler une image
        chaque instructuion va creer une couche d image pour l image

                Creation d un Dockerfile : doit Ãªtre sans extension touch DOCKER 
                    touch Dockerfile
                    vi Dockerfile
                    les instruction :
                                FROM debian:jessie
                                RUN apt-get update
                                RUN apt-get install -y git
                                RUN apt-get install -y vim
                                wq!

                    docker build pour creer notrer image avec les instruction :
                        docker build -t le_nom_quon_donne_a_limage lePath_ou_le_dockerfile_se_trouve:  docker build -t kimbo/debian .


                            Docker build commmand takes the path to the build context as an argument
                                    docker images


        DOCKER In-depth: CHAIN RUN INSTRUCTION 
                Each RUNN command will execute the command on the top writable layer  the container then commit container as a new image
                Each Run instruction willl create a new image layer
                it recommande to chain the Run INSTRUCTIONS in Dockerfile to reduce the numve of image layers int creates

                Rebulit IMAGE with less instructiion:
                    FROM debian:jessie
                    RUN apt-get update && apt-get install -y \
                    git \
                    vim
                    
                    Rebuild image :
                        docker build -t kimbo/debian .

                    On peut utiliser un package dans l image par exemple entre git et vim: 

                    FROM debian:jessie
                    RUN apt-get update && apt-get install -y \
                    git \
                    python
                    vim



        CMD Instructions :
            Specifie quelle commeande tu veux run quand tu debute ton container
            sinon on ne specifie pas le CMD ds le Dockerfile, on ne utilisera e default command de l image de Base
            pour debiand le default est bash 

                    $ cat Dockerfile
                    FROM debian:jessie
                    RUN apt-get update && apt-get install -y \
                    git \
                    vim
                    CMD ["echo", "kimbo dev"]

                    REBUILD:
                         docker build -t kimbo/debian .

                         docker run ID_IMAGE
                         WE CAN RUN OTHER LINE WITH 
                         docker run ID_IMAGE echov"Hello Docker"


        DOCKER Cache:
            Each time Docker executes an instruction it builds a neww image layer.

            we can disale cach :
                docker build -t kimbo/debian . --no-cache=true

        COPY Instruction :
            Avec l instruction COPY
            $ cat Dockerfile
                FROM debian:jessie
                RUN apt-get update && apt-get install -y \
                git \
                vim
                COPY file.py /scr/file.py
               Rubuild image and run container RUNC IMAG 


        ADD iNSRTRUCTION 
        ALLOW YOU DOWNLOAD FILE FROM INTERNET 
        CAN COMPRESSED FILE 



        ================= PUSH DOCKER IMAGES TO DOCKER HUB ===================
        To push image to DOCKER DockerHub
        Rename the Image :
            docker_hub_id / repository_name
            docker images
            docker tag 50cfe3e14717 kimbo/debian:1.01

Docker login : winpty docker login --username=kimbo150

docker push kimbo/debian:1.01

"docker login <url> --username=<username>"


CREATE CONTAINERIZED WEB APPLICATION 

             docker build -t dockerapp:v0.1 .
            docker images
            run notre container :
                docker run -d -p 5000:5000 b5913058a6d8
                -d: run conmtainer in background
                -p: expose le port
                par defaut python va rouler sur le port 5000 et le port 5000 host (l0cal)
                 docker run -d -p 5000:5000 b5913058a6d8
                    6a873a54b3b0c924fe66533dd87f10fbb63472e2cf597a2bcdc2aedb5b24fca8

                    On doit chercher quel IP python utilise : la commande docker-machie ls

                     docker exec -it ea940edda7e9 acceder via le bash


Implement a simple Key-value Lookup Service 


            stop container bdefore staert same cotainer with different tag : $ docker stop ea940edda7e9



Docker Container Links :
Allow diffeent container communicate each others : Recipeient >>> host >>> Source 

$ docker run -d -p 5000:5000 --link redis dockerappp:v0.2
2d519bc03a5212ead43ecaee7d5c4bc630738069824731ea1579462e28dcb796
Veriofy REdis IP : docker inspect 144f5832ec49 | grep IP
GO TO CONTAINER AND PING REDIS : winpty docker exec -it 2d519bc03a52 bash



AUTOMATE CURRENT WORKFLOW WITH DOCKER COMPOSE 
